#+TITLE:     Nix Tour
#+AUTHOR:    Mathis Antony
#+EMAIL:     sveitser@gmail.com

Work in Progress!
* TODO:
- Check doom emacs presentation mode.
- Make sure all packages are downloaded / run everything once.
- Overrides?

* Intro to Nix
- These slides: [[https://github.com/sveitser/nix-tour][github.com/sveitser/nix-tour]]
- My NixOS config: [[https://github.com/sveitser/nixconfig][github.com/sveitser/nixconfig]]

* Motivation
- 1001 forgotten/obsolete/... dependencies.
- The latest and greatest.
- APIs "subject to change yesterday".
- Can anyone run my code?
- Can I run my code in a year?

* Installation
- Native package manager on =NixOS=.
- Download from: [[https://nixos.org/nix][nixos.org/nix]]
- All in =/nix=, doesn't get in the way.

* Nix Language

- [[https://nixos.wiki/wiki/Nix_Expression_Language][nixos.wiki/wiki/Nix_Expression_Language]]
- Lazy! (overrideable)
- Run =nix repl=.
- Type =:?= for help.

** Examples:
#+BEGIN_SRC
plus = a: b: a + b
plus 2 3

plus-two = plus 2
plus-two 3

myList = [ 1 2 "blah" ];
mySet = { a = 1; b = "hello"; };
myPath = /this/is/a/path
myString = "this is a string"
five = let x = 2; in x + 3
map (x: x * 2) [1 2 3]
#+END_SRC

* Nix Package Manager
- Packages [[https://github.com/nixos/nixpkgs][github.com/nixos/nixpkgs]].
- Invoked with =nix=.
- nix "derivations".
- =nix build=
- =nix search=

* Nix shell
- Ad hoc: =nix-shell -p vim -p emacs=
#+BEGIN_SRC nix
with import <nixpkgs> { };
mkShell {
  buildInputs = [
    vim
    emacs
  ];
}
#+END_SRC
- Goes into =shell.nix=.
- Activate with =nix-shell=.

* Direnv
- Per directory "automagic" environment.
- See [[https://direnv.net][direnv.net]]
- Hook into shell =eval "$(direnv hook bash)"=
#+BEGIN_SRC bash
echo 'use nix' > .envrc
direnv allow
#+END_SRC
- nix-shell + virtualenv with direnv
#+BEGIN_SRC bash
echo layout_python >> .envrc
direnv allow
echo ipython > requirements.txt
pip install -r requirements.txt
#+END_SRC

* Nix shell: wrappers
- Convenience wrappers for many languages
#+BEGIN_SRC nix
with import <nixpkgs> { };
mkShell {
  buildInputs = [
    (python3Packages.withPackages (ps: [ps.ipython ps.tensorflow]))
    (haskellPackages.ghcWithPackages (ps: [ps.tensorflow ps.tensorflow-ops ps.HUnit]))
  ];
}
#+END_SRC
- Easy to pin =nixpkgs=.
* Nix shell: pinning
- Fix package tree.
- Pick git commit SHA of =nixpkgs= repo.
- Compute hash: =nix-prefetch-url --unpack https://github.com/nixos/nixpkgs/archive/$SHA.tar.gz=
#+BEGIN_SRC nix
with import (
  builtins.fetchTarball {
    url = "https://github.com/nixos/nixpkgs/archive/0a7e258012b60cbe530a756f09a4f2516786d370.tar.gz";
    sha256 = "1qcnxkqkw7bffyc17mqifcwjfqwbvn0vs0xgxnjvh9w0ssl2s036";
) { };
mkShell {
  buildInputs = [
    (python3Packages.withPackages (ps: [ps.ipython ps.pandas]))
  ];
}
#+END_SRC

* Disadvantages
- Learning curve.
- Not easily discoverable.
- Some extra storage space.
- (Very rarely) a package is hard to build.

* Advantages
- Reproducible.
- Cross platform.
- Works (fails) consistently.
- Actually fun.
- Totally worth it!
